name: Mirror Bazel NoJDK Windows Executable

on:
  workflow_dispatch:
    inputs:
      bazel_version:
        description: "Bazel version to mirror (e.g., 8.1.1)"
        required: true
        type: string
      tag_version:
        description: "Version for the release tag (e.g., 0.1.0)"
        required: false
        default: "0.1.0"
        type: string

jobs:
  mirror-bazel:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download and compress Bazel NoJDK executable
        id: download
        run: |
          # Download Bazel NoJDK
          BAZEL_VERSION="${{ github.event.inputs.bazel_version }}"
          BAZEL_URL="https://github.com/bazelbuild/bazel/releases/download/${BAZEL_VERSION}/bazel_nojdk-${BAZEL_VERSION}-windows-x86_64.exe"
          BAZEL_PATH="bazel_nojdk-${BAZEL_VERSION}-windows-x86_64.exe"
          echo "Downloading from ${BAZEL_URL}..."

          # Check if the URL exists before downloading
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${BAZEL_URL}")
          if [ "${HTTP_STATUS}" != "200" ] && [ "${HTTP_STATUS}" != "302" ]; then
            echo "Error: File does not exist at ${BAZEL_URL} (HTTP status: ${HTTP_STATUS})"
            exit 1
          fi

          curl -L -o "${BAZEL_PATH}" "${BAZEL_URL}"

          # Compress using maximum compression
          COMPRESSED_PATH="bazel_nojdk-${BAZEL_VERSION}-windows-x86_64.zip"
          echo "Compressing to ${COMPRESSED_PATH}..."
          zip -9 "${COMPRESSED_PATH}" "${BAZEL_PATH}"

          # Verify file sizes
          ORIGINAL_SIZE=$(ls -l "${BAZEL_PATH}" | awk '{print $5}')
          COMPRESSED_SIZE=$(ls -l "${COMPRESSED_PATH}" | awk '{print $5}')
          echo "Original size: ${ORIGINAL_SIZE} bytes"
          echo "Compressed size: ${COMPRESSED_SIZE} bytes"

          # Set outputs
          echo "compressed_path=${COMPRESSED_PATH}" >> $GITHUB_OUTPUT
          echo "version=${BAZEL_VERSION}" >> $GITHUB_OUTPUT

      - name: Check for existing release and update
        id: check_release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            function generateReleaseBody(version, dateString, existingVersions = []) {
              const header = [
                '# Zip Assets of Binaries',
                '',
                'This repository provides Windows executables as ZIP files.',
                '',
                '## Available versions:'
              ].join('\n');
              
              const newVersion = `- ${version} (bazel_nojdk-${version}-windows-x86_64.zip, added on ${dateString})`;
              
              return [
                header,
                newVersion,
                ...existingVersions
              ].join('\n');
            }

            const tagVersion = '${{ github.event.inputs.tag_version }}';
            const tagName = `v${tagVersion}`;
            const version = "${{ steps.download.outputs.version }}";
            const dateString = new Date().toISOString().split('T')[0];
            let releaseId;
            let uploadUrl;
            let releaseExists = false;

            try {
              const release = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              
              releaseId = release.data.id;
              uploadUrl = release.data.upload_url;
              releaseExists = true;
              
              // Get existing versions from current body, excluding current version
              const existingVersions = (release.data.body || '')
                .split('\n')
                .filter(line => line.startsWith('- '))
                .filter(line => !line.includes(`${version} (`));
              
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                body: generateReleaseBody(version, dateString, existingVersions)
              });
            } catch (error) {
              console.log(`Release with tag ${tagName} not found. Will create it.`);
              releaseExists = false;
            }

            core.setOutput('release_id', releaseId);
            core.setOutput('release_exists', releaseExists.toString());
            core.setOutput('upload_url', uploadUrl);
            return { releaseId, releaseExists, uploadUrl };

      - name: Create release if it doesn't exist
        id: create_release
        if: steps.check_release.outputs.release_exists != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const version = "${{ steps.download.outputs.version }}";
            const tagVersion = '${{ github.event.inputs.tag_version }}';
            const tagName = `v${tagVersion}`;
            const dateString = new Date().toISOString().split('T')[0];

            try {
              const release = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tagName,
                name: 'Zip Assets',
                body: generateReleaseBody(version, dateString),
                draft: false,
                prerelease: false,
                generate_release_notes: false
              });
              
              core.setOutput('release_id', release.data.id);
              core.setOutput('upload_url', release.data.upload_url);
              return release.data;
            } catch (error) {
              console.log(error);
              core.setFailed('Failed to create release');
            }

      - name: Delete existing asset if it exists
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const assetName = 'bazel_nojdk-${{ steps.download.outputs.version }}-windows-x86_64.zip';
            const releaseId = ${{ steps.check_release.outputs.release_id || steps.create_release.outputs.release_id }};

            if (!releaseId) {
              console.log('No release ID found, skipping asset deletion');
              return;
            }

            const assets = await github.rest.repos.listReleaseAssets({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              per_page: 100
            });

            for (const asset of assets.data) {
              if (asset.name === assetName) {
                console.log(`Deleting existing asset: ${assetName}`);
                await github.rest.repos.deleteReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  asset_id: asset.id
                });
              }
            }

      - name: Upload asset to release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const { repo } = context;
            const uploadUrl = '${{ steps.check_release.outputs.upload_url || steps.create_release.outputs.upload_url }}';
            const assetPath = '${{ steps.download.outputs.compressed_path }}';
            const assetName = '${{ steps.download.outputs.compressed_path }}';

            const contentLength = fs.statSync(assetPath).size;
            const contentType = 'application/zip';
            const headers = { 
              'content-type': contentType,
              'content-length': contentLength
            };

            const data = fs.readFileSync(assetPath);
            const uploadResponse = await github.rest.repos.uploadReleaseAsset({
              url: uploadUrl,
              headers,
              name: assetName,
              data
            });

            console.log(`Asset uploaded successfully: ${uploadResponse.data.browser_download_url}`);
